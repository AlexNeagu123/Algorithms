struct seg_tree {

    int sz;
    vector<item> val;

    void init(int x) {
        sz = 1;
        while(sz < x) sz *= 2;
        val.resize(sz * 2);
    }

    item merge(item a, item b) {
        item ans;
        ans.mx = max({a.mx, b.mx, a.suf + b.pre});
        ans.pre = max({a.pre, a.sum + b.pre});
        ans.suf = max({b.suf, b.sum + a.suf});
        ans.sum = a.sum + b.sum;
        return ans;
    }

    void build(int node, int l, int r, vector<ll>& a) {
        if (r - l == 1) {
            if (l < a.size()) {
                val[node] = item{a[l], a[l], a[l], a[l]};
            }
            return;
        }
        int mid = (l + r) / 2;
        build(node * 2 + 1, l, mid, a);
        build(node * 2 + 2, mid, r, a);
        val[node] = merge(val[node * 2 + 1], val[node * 2 + 2]);
    }   

    void build(vector<ll>& a) {
        build(0, 0, sz, a);
    }

    void upd(int node, int l, int r, int pos, ll x) {
        if (r - l == 1) {
            val[node] = item{x, x, x, x};
            return;
        }
        int mid = (l + r) / 2;
        if (mid > pos) upd(node * 2 + 1, l, mid, pos, x);
        if (mid <= pos) upd(node * 2 + 2, mid, r, pos, x);
        val[node] = merge(val[node * 2 + 1], val[node * 2 + 2]);
    }
    void upd(int pos, ll x) {
        upd(0, 0, sz, pos, x);
    }

    ll ask(int node, int l, int r, int st, int dr) {
        if (dr <= l || st >= r) return -inf;
        if (l >= st && r <= dr) return val[node].mx;
        int mid = (l + r) / 2;
        return max(ask(node * 2 + 1, l, mid, st, dr),
            ask(node * 2 + 2, mid, r, st, dr));
    }
    ll ask() {
        return ask(0, 0, sz, 0, sz);
    }
};
