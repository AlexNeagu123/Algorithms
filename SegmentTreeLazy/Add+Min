struct segment_tree {
 
    int size;
 
    vector<ll> val;
    vector<ll> lazy;
 
    void init(int n) {
 
        size = 1;
        while(size < n) size *= 2;
 
        val.assign(size * 2, 0);
        lazy.assign(size * 2, 0);
 
    }
 
    ll merge(ll a, ll b) {
 
        return min(a, b);
 
    }
 
 
    void propagate(int node, int l, int r) {
 
        if (l == r - 1) {
            return;
        }
 
        for(int x : {2 * node + 1, 2 * node + 2}) {
 
            val[x] += lazy[node];
            lazy[x] += lazy[node];
 
        }
 
        lazy[node] = 0;
 
    }
 
    void add(int node, int lf, int rg, int l, int r, int x) {
 
        propagate(node, l, r);
 
        if (l >= rg || r <= lf) return;
 
        if (l >= lf && r <= rg) {
            
            val[node] += x;
            lazy[node] += x;
            
            return;
        }
 
        int mid = (l + r) / 2;
 
        add(node * 2 + 1, lf, rg, l, mid, x);
        add(node * 2 + 2, lf, rg, mid, r, x);
 
        val[node] = merge(val[node * 2 + 1], val[node * 2 + 2]);
 
    }
 
    void add(int l, int r, int x) {
 
        add(0, l, r, 0, size, x);
 
    }
 
    ll get(int node, int lf, int rg, int l, int r) {
 
        propagate(node, l, r);
 
        if (l >= rg || r <= lf) return neutral;
        if (l >= lf && r <= rg) return val[node];
 
        int mid = (l + r) / 2;
 
        return merge(get(node * 2 + 1, lf, rg, l, mid),
            get(node * 2 + 2, lf, rg, mid, r));
        
    }
    ll get(int l, int r) {
 
        return get(0, l, r, 0, size);
 
    }
};
