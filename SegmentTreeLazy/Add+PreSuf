struct segment_tree {
 
    int size;
 
    vector<item> val;
    vector<ll> lazy;
 
    void init(int n) {
 
        size = 1;
        while(size < n) size *= 2;
 
        val.resize(size * 2);
        lazy.assign(size * 2, 0);
 
    }
 
    item merge(item a, item b) {

        item ans;

        ans.sum = a.sum + b.sum;
        ans.pre = max(a.pre, a.sum + b.pre);
        ans.suf = max(b.suf, b.sum + a.suf);
        ans.mx = max({a.suf + b.pre, a.mx, b.mx});

        return ans;  

    }
    
    void build(int node, int l, int r, vector<int>&a) {
        if(r - l == 1) {
            if (l < a.size()) {
                val[node] = {a[l], a[l], a[l], a[l]};
            } else {
                val[node] = neutral;
            }
            return;
        }

        int mid = (l + r) / 2;
        
        build(node * 2 + 1, l, mid, a);
        build(node * 2 + 2, mid, r, a);

        val[node] = merge(val[node * 2 + 1], val[node * 2 + 2]);

    }
    void build(vector<int>&a) {
        build(0, 0, size, a);
    }

    void add_lazy(ll &a, ll b) {
        if (b != not_added) a = b;
    }
    
    void add_val(item &a, ll x, ll len) {

        if (x == not_added) {
            return;
        }

        if (x <= 0) {
            a.mx = 0;
            a.pre = x;
            a.suf = x;
            a.sum = x * len;
        } 
        else {
            a.sum = a.pre = a.suf = a.mx = x * len;
        }

    }
    void propagate(int node, int l, int r) {
 
        if (l == r - 1) {
            return;
        }
        
        int mid = (l + r) / 2;

        for(int x : {2 * node + 1, 2 * node + 2}) {
        
            add_val(val[x], lazy[node], mid - l);
            add_lazy(lazy[x], lazy[node]);
 
        }
 
        lazy[node] = not_added;
 
    }
 
    void add(int node, int lf, int rg, int l, int r, int x) {
 
        propagate(node, l, r);
 
        if (l >= rg || r <= lf) return;
 
        if (l >= lf && r <= rg) {
            
            add_lazy(lazy[node], x);
            add_val(val[node], x, r - l);
 
            return;
        }
 
        int mid = (l + r) / 2;
 
        add(node * 2 + 1, lf, rg, l, mid, x);
        add(node * 2 + 2, lf, rg, mid, r, x);
 
        val[node] = merge(val[node * 2 + 1], val[node * 2 + 2]);
 
    }
 
    void add(int l, int r, int x) {
 
        add(0, l, r, 0, size, x);
 
    }
 
    item get(int node, int lf, int rg, int l, int r) {
 
        propagate(node, l, r);
 
        if (l >= rg || r <= lf) return neutral;
        if (l >= lf && r <= rg) return val[node];
 
        int mid = (l + r) / 2;
 
        return merge(get(node * 2 + 1, lf, rg, l, mid),
            get(node * 2 + 2, lf, rg, mid, r));
        
    }
    item get(int l, int r) {
 
        return get(0, l, r, 0, size);
 
    }
};
 
